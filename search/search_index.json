{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kotlin in FRC","text":""},{"location":"developing/migrating/","title":"Migrating your Java Code into Kotlin","text":"<p>A good way to learn how Kotlin works is to convert your existing Java code into Kotlin. Kotlin is interoperable with Java, so you can use both languages in the same project.</p>"},{"location":"developing/migrating/#adding-kotlin-to-your-project","title":"Adding Kotlin to your Project","text":""},{"location":"developing/migrating/#adding-the-kotlin-plugin","title":"Adding the Kotlin Plugin","text":"<p>To enable Kotlin in your WPILib project, add the Kotlin plugin to your Gradle build file. In the <code>build.gradle</code> file, add the following plugin to the <code>plugins</code> block:</p> <pre><code>plugins {\n    id 'org.jetbrains.kotlin.jvm' version '2.0.20'\n}\n</code></pre>"},{"location":"developing/migrating/#add-kotlin-usage-reporting","title":"Add Kotlin Usage Reporting","text":"<p>To help the FRC community keep track of how many teams use Kotlin as a programming language, we recommend adding the following lines to your <code>Robot.java</code> constructor</p> <pre><code>HAL.report(tResourceType.kResourceType_Language, tInstances.kLanguage_Kotlin);\n</code></pre>"},{"location":"developing/migrating/#creating-a-new-kotlin-file","title":"Creating a new Kotlin File","text":"<p>To create a new Kotlin file, right-click on the <code>src/main/java</code> folder in your project and select <code>New -&gt; Kotlin File/Class</code>.</p>"},{"location":"developing/migrating/#migrating-an-existing-java-file","title":"Migrating an existing Java file","text":"<p>To convert an existing Java file into Kotlin, right-click on the Java file in the tree view and select 'Convert Java File to Kotlin File'</p>"},{"location":"developing/migrating/#common-migration-issues","title":"Common migration issues","text":""},{"location":"developing/migrating/#final-keyword","title":"<code>final</code> keyword","text":"<p>In Kotlin, the <code>final</code> keyword is not used. Instead, you can use the <code>val</code> keyword to declare a read-only variable.</p> <pre><code>// Java\nfinal int x = 5;\n</code></pre> <pre><code>// Kotlin\nval x = 5\n</code></pre>"},{"location":"developing/migrating/#static-keyword","title":"<code>static</code> keyword","text":"<p>In Kotlin, the <code>static</code> keyword is not used. Instead, you can use the <code>companion object</code> keyword to declare a static field or method.</p> <pre><code>// Java\npublic static void foo() {\n    System.out.println(\"Hello, World!\");\n}\n\npublic static final int x = 5;\n</code></pre> <pre><code>// Kotlin\ncompanion object {\n    fun foo() {\n        println(\"Hello, World!\")\n    }\n\n    val x = 5\n}\n</code></pre>"},{"location":"developing/migrating/#nullability","title":"Nullability","text":"<p>In Kotlin, types must be declared as 'nullable' if they can have a value of 'null'. For many types used in FRC, this is not necessary as their values are never 'null'. When converting Java code to Kotlin, some types may become marked as nullable with a <code>?</code>. This can be removed if you are sure that the value will never be <code>null</code>.</p> <pre><code>// Java\npublic Command exampleSubsystemCommand() {\n    return runOnce(() -&gt; motor.set(1));\n}\n</code></pre> <p>After conversion, the return type of the method may be marked as nullable</p> <pre><code>// Kotlin with nullable return type\nfun exampleSubsystemCommand(): Command? {\n    return runOnce { motor.set(1) }\n}\n</code></pre> <p>You can remove the <code>?</code> if you are sure that the value will never be <code>null</code>.</p> <pre><code>// Kotlin with non-nullable return type\nfun exampleSubsystemCommand(): Command {\n    return runOnce { motor.set(1) }\n}\n</code></pre> <p>Similar changes may be necessary for other types in your code. IntelliJ will usually suggest these changes for you.</p>"},{"location":"developing/migrating/#nullable-and-notnull","title":"@Nullable and @NotNull","text":"<p>If your team uses the <code>@Nullable</code> and <code>@NotNull</code> annotations in Java, you can remove these and use <code>?</code> to mark a type as nullable.</p>"},{"location":"getting-started/running/","title":"Running your Robot Program","text":""},{"location":"getting-started/running/#deploying-to-the-robot","title":"Deploying to the Robot","text":"<p>To deploy your robot program to the robot, you will need to use the <code>deploy</code> gradle command. This command will compile your robot program and deploy it to the robot.</p> <p>There are two ways of running the <code>deploy</code> command:</p> <ul> <li>Through the command line</li> <li>Through a run configuration in IntelliJ</li> </ul>"},{"location":"getting-started/running/#deploying-manually-via-the-command-line","title":"Deploying manually via the command line","text":"<ol> <li> <p>Open a terminal window. You can use the terminal window in IntelliJ or your system terminal. To    open the terminal window in IntelliJ, click on the terminal tab at the bottom of the window or    <code>View &gt; Tool Windows &gt; Terminal</code>.</p> </li> <li> <p>Navigate to the root directory of your robot program. If you are using the terminal in IntelliJ,    you can use the <code>cd</code> command to navigate to the root directory of your robot program.</p> </li> <li> <p>Run the <code>deploy</code> command by typing <code>./gradlew deploy</code> (<code>gradlew.bat deploy</code> on Windows) and    pressing enter.</p> </li> </ol>"},{"location":"getting-started/running/#deploying-via-intellij","title":"Deploying via IntelliJ","text":"<ol> <li>Create a new run configuration by clicking on the dropdown next to the run button in the top    right corner of the IntelliJ window and selecting <code>Edit Configurations</code>.</li> <li> <p>Click on the <code>+</code> button in the top left corner of the window and select <code>Gradle</code>. Under the <code>Run</code>    field type <code>deploy</code>. The <code>Gradle project</code> should be your project. Click <code>OK</code>.    </p> </li> <li> <p>Click on the run button in the top right corner of the IntelliJ window to deploy your robot    program to the robot.</p> </li> </ol>"},{"location":"getting-started/running/#simulating-robot-code","title":"Simulating Robot Code","text":"<p>FRC code made with kotlin can be simulated on your computer, just like robot code written with Java, Python, or C++. To do so, either follow the \"Deploying via IntelliJ\" or \"Deploying manually via the command line\" instructions above, but replace the \"deploy\" task with the \"simulateJava\" task (i.e <code>./gradlew simulateJava</code> on Windows Powershell or a Unix shell).</p> <p>WPILib's simulation allows you to run your code locally on your computer, without an actual robot. This should be used in conjunction with the WPILib simulation classes to simulate your mechanisms; read more about the physics simulation API here.</p>"},{"location":"getting-started/why-kotlin/","title":"Why use Kotlin for FRC Programming","text":""},{"location":"getting-started/why-kotlin/#official-and-community-support","title":"Official and Community Support","text":"<p>WPILib provides official support for the Java programming language. Because Kotlin is fully compatible with Java, you can use Kotlin with WPILib without any issues.</p> <p>Any issues you encounter while using Kotlin with WPILib are likely to be issues common to both Kotlin and Java, and you can find help in the WPILib community.</p>"},{"location":"getting-started/why-kotlin/#implicit-typing","title":"Implicit Typing","text":"<p>Kotlin has type inference, which means you don't have to explicitly declare a variable's type when you initialize it. This can make writing code more straightforward for new students. Your IDE can still show you type information when you need it.</p> <pre><code>val x = 5 // x is an Int\nval y = \"hello\" // y is a String   \n</code></pre> <p>More info about type inference can be found here.</p>"},{"location":"getting-started/why-kotlin/#null-safety","title":"Null Safety","text":"<p>While a less common problem in FRC programming, null pointer exceptions can still occur. Kotlin provides null safety features that can help you avoid these issues.</p> <pre><code>var x: String = \"hello\" // x cannot be null\nvar y: String? = null // y can be null\n</code></pre> <p>More info about null safety can be found here.</p>"},{"location":"getting-started/why-kotlin/#default-arguments","title":"Default Arguments","text":"<p>In Kotlin, you can provide default values for function parameters. This can make your code more concise, as you don't have to provide overloads for every possible combination of parameters.</p> <p>Java:</p> <pre><code>public void foo(int x, int y) {\n  foo(x, y, 0);\n}\n\npublic void foo(int x, int y, int z) {\n  // do something\n}\n</code></pre> <p>Kotlin:</p> <pre><code>fun foo(x: Int, y: Int, z: Int = 0) {\n    // do something\n}\n</code></pre> <p>More info about default arguments can be found here.</p>"},{"location":"getting-started/why-kotlin/#extension-functions","title":"Extension Functions","text":"<p>Kotlin allows you to add new functions to existing classes without modifying the class itself. This allows you to add functionality to classes you don't own, such as vendor libraries.</p> <p>Here we add an <code>optimizeBusUtilization</code> function to the <code>CANSparkMax</code> class:</p> <pre><code>fun CANSparkMax.optimizeBusUtilization() {\n    setPeriodicFramePeriod(PeriodicFrame.kStatus0, 32767)\n    // ...\n}\n\nval motor = CANSparkMax(1, MotorType.kBrushless)\nmotor.optimizeBusUtilization() // call the extension function\n</code></pre> <p>More info about extension functions can be found here.</p>"},{"location":"getting-started/why-kotlin/#operator-overloading","title":"Operator Overloading","text":"<p>A commonly requested feature in Java is operator overloading. Kotlin allows you to overload operators for your classes. Combined with extension functions, this can make your code more readable and concise.</p> <p>Many WPILib math classes support operator overloads due to their method naming conventions.</p> <pre><code>// Cannot use + operator in java\nRotation2d sum = rotation1.plus(rotation2);\n</code></pre> <pre><code>// + operator calls `plus` method\nval sum = rotation1 + rotation2\n</code></pre> <p>For classes that don't already support operator overloads, you can add support via extension functions.</p> <p>More info about operator overloading can be found here.</p>"},{"location":"getting-started/why-kotlin/#reduced-boilerplate","title":"Reduced Boilerplate","text":"<p>Kotlin is a more concise language than Java, which means you can write the same functionality with less code. This can make your code easier to read and maintain. It also makes it easier for new students to learn the language.Consider the following two examples:</p> <pre><code>public class ExampleCommand extends CommandBase {\n\n  private final ExampleSubsystem subsystem;\n\n  public ExampleCommand(ExampleSubsystem subsystem) {\n    this.subsystem = subsystem;\n    addRequirements(subsystem);\n  }\n}\n</code></pre> <pre><code>class ExampleCommand(private val subsystem: ExampleSubsystem) : CommandBase() {\n    init {\n        addRequirements(subsystem)\n    }\n}\n</code></pre> <p>In the java example, we have to declare the type of the <code>subsystem</code> variable twice, and we have to assign the variable in the constructor. In the Kotlin example, the declaration and assignment are combined into a single line.</p>"}]}